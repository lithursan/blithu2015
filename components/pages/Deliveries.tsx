import React, { useMemo, useState } from 'react';
import { Modal } from '../ui/Modal';
import { useData } from '../../contexts/DataContext';
import { supabase } from '../../supabaseClient';
import { Card, CardContent, CardHeader, CardTitle } from '../ui/Card';
import { Badge } from '../ui/Badge';
import { OrderStatus, DriverAllocation } from '../../types';
import html2pdf from 'html2pdf.js';
import { COMPANY_DETAILS } from '../../constants';

// Deliveries page: group orders by expected delivery date, aggregate product quantities
export const Deliveries: React.FC = () => {
  const { orders, products, users, driverAllocations, setDriverAllocations, refetchData } = useData();
  const [selectedDate, setSelectedDate] = useState<string>('');
  const [allocatingToDriver, setAllocatingToDriver] = useState<string | null>(null);
  const [allocationsLocal, setAllocationsLocal] = useState<Record<string, { productId: string; qty: number }[]>>({});
  const [loading, setLoading] = useState(false);

  // Group orders by expectedDeliveryDate (or order date if missing)
  const ordersByDate = useMemo(() => {
    // Only include orders that are Pending (exclude already Delivered)
    return orders.reduce((acc: Record<string, any[]>, order) => {
      if (order.status !== OrderStatus.Pending) return acc;
      const date = (order.expectedDeliveryDate || order.date || '').slice(0, 10) || 'unspecified';
      if (!acc[date]) acc[date] = [];
      acc[date].push(order);
      return acc;
    }, {} as Record<string, any[]>);
  }, [orders]);

  // Aggregate products for selectedDate
  const aggregatedProducts = useMemo(() => {
    if (!selectedDate) return [];
    const dateOrders = ordersByDate[selectedDate] || [];
    const map = new Map<string, number>();
    dateOrders.forEach(order => {
      (order.orderItems || []).forEach((item: any) => {
        const prev = map.get(item.productId) || 0;
        map.set(item.productId, prev + (item.quantity || 0));
      });
    });
    return Array.from(map.entries()).map(([productId, qty]) => ({ productId, qty }));
  }, [ordersByDate, selectedDate]);

  const drivers = users.filter(u => u.role === 'Driver');

  // Modal state for allocating directly from the date list
  const [dateAllocateModal, setDateAllocateModal] = useState<{ date: string } | null>(null);
  const [dateAllocateDriver, setDateAllocateDriver] = useState<string>('');

  // Set of dates that already have an allocation (any driver)
  const allocatedDates = React.useMemo(() => {
    const set = new Set<string>();
    (driverAllocations || []).forEach((a: any) => {
      if (a && a.date) set.add(a.date.slice ? a.date.slice(0, 10) : a.date);
    });
    return set;
  }, [driverAllocations]);

  const handleAllocate = async (driverId: string) => {
    if (!selectedDate) return;
    if (aggregatedProducts.length === 0) {
      alert('No products to allocate for the selected date.');
      return;
    }
    // Prevent allocation if the date already has an allocation for any driver
    if (allocatedDates.has(selectedDate)) {
      alert('This date has already been allocated to a driver. Only one allocation per date is allowed.');
      return;
    }
    // Prevent duplicate allocation for same driver & date
    try {
      const { data: existing, error: existError } = await supabase.from('driver_allocations').select('*').eq('driver_id', driverId).eq('date', selectedDate).limit(1);
      if (!existError && existing && existing.length > 0) {
        // If an allocation already exists for this driver/date, skip silently (no confirm)
        alert('An allocation for this driver on the selected date already exists.');
        return;
      }
    } catch (err) {
      console.warn('Failed to check existing allocations:', err);
    }

    // Build allocation record for driver
    const items = aggregatedProducts.map(p => ({ productId: p.productId, quantity: p.qty }));
    const newAlloc: DriverAllocation = {
      id: `ALLOC-${Date.now()}`,
      driverId,
      driverName: users.find(u => u.id === driverId)?.name || '',
      date: selectedDate,
      allocatedItems: items as any,
      returnedItems: null,
      salesTotal: 0,
      status: 'Allocated',
    };
    setLoading(true);
    // Insert into Supabase driver_allocations table
    try {
      // Do not provide an explicit id if the DB column is a UUID generated by Postgres
      const { data, error } = await supabase.from('driver_allocations').insert([
        {
          driver_id: newAlloc.driverId,
          driver_name: newAlloc.driverName,
          date: newAlloc.date,
          allocated_items: JSON.stringify(newAlloc.allocatedItems),
          returned_items: null,
          sales_total: 0,
          status: newAlloc.status,
        }
      ]).select(); // return the inserted row(s)
      setLoading(false);
      if (error) {
        alert('Failed to allocate to driver: ' + error.message);
        return;
      }
      const inserted = Array.isArray(data) && data.length > 0 ? data[0] as any : null;
      const returnedId = inserted?.id ?? newAlloc.id;
      const allocWithId = { ...newAlloc, id: returnedId };
  // Update local state and DataContext fetch (silent success)
  setDriverAllocations(prev => [...prev, allocWithId]);
  await refetchData();
    } catch (err: any) {
      setLoading(false);
      console.error(err);
      alert('Failed to allocate: ' + err?.message);
    }
  };

  // Find allocation object for selectedDate (if any)
  const allocationForSelectedDate = React.useMemo(() => {
    if (!selectedDate || !driverAllocations) return null;
    return (driverAllocations as any[]).find(a => {
      if (!a || !a.date) return false;
      const d = a.date.slice ? a.date.slice(0, 10) : a.date;
      return d === selectedDate;
    }) || null;
  }, [selectedDate, driverAllocations]);

  // Helper: find allocation object for an arbitrary date
  const getAllocationForDate = (date: string) => {
    if (!driverAllocations) return null;
    return (driverAllocations as any[]).find(a => {
      if (!a || !a.date) return false;
      const d = a.date.slice ? a.date.slice(0, 10) : a.date;
      return d === date;
    }) || null;
  };

  const handleUnallocateForDate = async (date: string) => {
    const alloc = getAllocationForDate(date);
    if (!alloc) {
      alert('No allocation found for that date.');
      return;
    }
    const driverName = alloc.driverName || alloc.driver_name || (() => {
      const driverId = alloc.driverId || alloc.driver_id;
      const u = users.find((usr: any) => usr.id === driverId);
      return u ? u.name : 'driver';
    })();
  // Remove without browser confirmation, show alert after
    try {
      const id = alloc.id;
      if (!id) { alert('Allocation id missing'); return; }
      const { error } = await supabase.from('driver_allocations').delete().eq('id', id);
      if (error) { alert('Failed to remove allocation: ' + error.message); return; }
  setDriverAllocations(prev => (prev || []).filter(a => a.id !== id));
  await refetchData();
    } catch (err) {
      console.error('Unallocate error:', err);
      alert('Failed to remove allocation. See console.');
    }
  };

  const handleUnallocate = async () => {
    if (!allocationForSelectedDate) return;
    // Resolve driver display name reliably
    const driverName = allocationForSelectedDate.driverName || allocationForSelectedDate.driver_name || (() => {
      const driverId = allocationForSelectedDate.driverId || allocationForSelectedDate.driver_id;
      const u = users.find((usr: any) => usr.id === driverId);
      return u ? u.name : 'driver';
    })();

    // Remove without browser confirmation; proceed immediately
    try {
      const id = allocationForSelectedDate.id;
      if (!id) {
        alert('Cannot remove allocation: allocation record id is missing.');
        return;
      }
      const { error } = await supabase.from('driver_allocations').delete().eq('id', id);
      if (error) {
        alert('Failed to remove allocation: ' + error.message);
        return;
      }
  // Update local DataContext state and refetch
  setDriverAllocations(prev => (prev || []).filter(a => a.id !== id));
  await refetchData();
    } catch (err) {
      console.error('Unallocate error:', err);
      alert('Failed to remove allocation. See console for details.');
    }
  };

  const handlePrintAggregated = () => {
    if (!selectedDate) {
      alert('Please select a date to print.');
      return;
    }
    if (aggregatedProducts.length === 0) {
      alert('No products to print for the selected date.');
      return;
    }

    const rowsHtml = aggregatedProducts.map(row => {
      const prod = products.find(p => p.id === row.productId);
      const name = prod?.name || row.productId;
      return `<tr><td style="padding:4px 0;">${name}</td><td style="padding:4px 0;text-align:right;">${row.qty}</td></tr>`;
    }).join('');

    const billHTML = `
      <!doctype html>
      <html>
        <head>
          <meta charset="utf-8" />
          <title>Deliveries - ${selectedDate}</title>
          <style>
            body { font-family: Arial, Helvetica, sans-serif; color: #000; width: 80mm; margin: 0; padding: 6px; }
            .center { text-align: center; }
            table { width: 100%; border-collapse: collapse; font-size: 12px; }
            td { vertical-align: top; }
            .header { margin-bottom: 6px; }
            .company { font-weight: bold; font-size: 14px; }
            .date { font-size: 11px; margin-bottom: 6px; }
            .divider { border-top: 1px dashed #000; margin: 6px 0; }
          </style>
        </head>
        <body>
          <div class="center header">
            <div class="company">${COMPANY_DETAILS.name}</div>
            <div class="date">${COMPANY_DETAILS.address || ''}</div>
            <div class="date">${COMPANY_DETAILS.phone || ''}</div>
            <div class="date">Delivery Date: ${selectedDate}</div>
          </div>
          <div class="divider"></div>
          <table>
            <thead>
              <tr>
                <td style="font-weight:bold;">Product</td>
                <td style="font-weight:bold;text-align:right;">Qty</td>
              </tr>
            </thead>
            <tbody>
              ${rowsHtml}
            </tbody>
          </table>
          <div class="divider"></div>
          <div style="text-align:center;font-size:11px;margin-top:6px;">Thank you - ${COMPANY_DETAILS.name}</div>
        </body>
      </html>
    `;

    const height = Math.max(200, 20 + aggregatedProducts.length * 12);
    const options = {
      margin: 1,
      filename: `Deliveries-${selectedDate}.pdf`,
      image: { type: 'jpeg', quality: 1 },
      html2canvas: { scale: 2 },
      jsPDF: { unit: 'mm', format: [80, height], orientation: 'portrait' }
    } as any;

    html2pdf().set(options).from(billHTML).save();
  };

  // Confirm Delivery removed - deliveries are handled per-order via Orders page / Drivers flow

  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-4">Deliveries</h1>
      <div className="grid grid-cols-3 gap-4">
        <div className="col-span-1">
          <Card>
            <CardHeader>
              <CardTitle>Delivery Dates</CardTitle>
            </CardHeader>
            <CardContent>
              <ul>
                {Object.keys(ordersByDate).length === 0 && <li className="py-2">No scheduled deliveries</li>}
                {Object.keys(ordersByDate).sort().map(date => {
                  const isAllocated = allocatedDates.has(date);
                  return (
                  <li key={date} className={`py-2 cursor-pointer ${selectedDate === date ? 'font-bold' : ''}`} onClick={() => setSelectedDate(date)}>
                    <div className="flex justify-between items-center">
                      <div className={isAllocated ? 'text-green-400' : ''}>{date}</div>
                      <div className="flex items-center space-x-2">
                        {!isAllocated && (
                          <button
                            onClick={(e) => { e.stopPropagation(); setDateAllocateModal({ date }); setDateAllocateDriver(''); }}
                            className="px-2 py-1 bg-blue-600 text-white rounded text-xs"
                          >Allocate</button>
                        )}
                        {isAllocated && (
                          <button
                            onClick={(e) => { e.stopPropagation(); handleUnallocateForDate(date); }}
                            className="px-2 py-1 bg-red-600 text-white rounded text-xs"
                          >Unallocate</button>
                        )}
                        <Badge variant={isAllocated ? 'success' : 'default'}>{ordersByDate[date].length}</Badge>
                      </div>
                    </div>
                  </li>
                )})}
              </ul>
            </CardContent>
          </Card>
        </div>

        <div className="col-span-2">
          <Card>
            <CardHeader>
              <CardTitle>Aggregated Products for {selectedDate || '—'}</CardTitle>
            </CardHeader>
            <CardContent>
              {aggregatedProducts.length === 0 ? (
                <div className="py-4">Select a date to see aggregated products</div>
              ) : (
                <table className="w-full text-sm">
                  <thead>
                    <tr>
                      <th className="text-left">Product</th>
                      <th className="text-right">Qty</th>
                      <th className="text-right">Stock</th>
                    </tr>
                  </thead>
                  <tbody>
                    {aggregatedProducts.map(row => {
                      const prod = products.find(p => p.id === row.productId);
                      return (
                        <tr key={row.productId} className="border-b">
                          <td>{prod?.name || row.productId}</td>
                          <td className="text-right">{row.qty}</td>
                          <td className="text-right">{prod?.stock ?? 'N/A'}</td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              )}

              <div className="mt-4 flex items-center gap-3">
                <select value={allocatingToDriver ?? ''} onChange={(e) => setAllocatingToDriver(e.target.value)} className="p-2 border border-slate-300 rounded bg-slate-50 dark:bg-slate-700 text-slate-900 dark:text-slate-100">
                  <option value="">Assign to driver (optional)</option>
                  {drivers.map(d => (
                    <option key={d.id} value={d.id}>{d.name}</option>
                  ))}
                </select>
                  <button
                    onClick={() => allocatingToDriver ? handleAllocate(allocatingToDriver) : alert('Select a driver to allocate')}
                    className={`px-4 py-2 rounded ${allocatedDates.has(selectedDate) ? 'bg-green-600 text-white' : 'bg-blue-600 text-white'}`}
                    disabled={!allocatingToDriver || aggregatedProducts.length === 0 || loading || allocatedDates.has(selectedDate)}
                  >{allocatedDates.has(selectedDate) ? 'Allocated' : (loading ? 'Allocating...' : 'Allocate')}</button>
                  {allocatedDates.has(selectedDate) && (
                    <button onClick={handleUnallocate} className="px-4 py-2 bg-red-600 text-white rounded ml-2">Unallocate</button>
                  )}
                <button onClick={handlePrintAggregated} className="px-4 py-2 bg-gray-600 text-white rounded" disabled={aggregatedProducts.length === 0}>Print</button>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
      {/* Date allocate modal */}
      {dateAllocateModal && (
        <Modal isOpen={true} onClose={() => setDateAllocateModal(null)} title={`Allocate ${dateAllocateModal.date}`}>
          <div className="p-4">
            <label className="block text-sm mb-2">Assign to driver</label>
            <select value={dateAllocateDriver} onChange={(e) => setDateAllocateDriver(e.target.value)} className="w-full p-2 border border-slate-300 rounded mb-4 bg-slate-50 dark:bg-slate-700 text-slate-900 dark:text-slate-100">
              <option value="">Select driver</option>
              {drivers.map(d => <option key={d.id} value={d.id}>{d.name}</option>)}
            </select>
            <div className="flex justify-end">
              <button onClick={async () => {
                if (!dateAllocateDriver) { alert('Select a driver'); return; }
                // set selectedDate and call handleAllocate
                setSelectedDate(dateAllocateModal.date);
                await handleAllocate(dateAllocateDriver);
                setDateAllocateModal(null);
              }} className="px-3 py-2 bg-blue-600 text-white rounded">Confirm</button>
            </div>
          </div>
        </Modal>
      )}
    </div>
  );
};
